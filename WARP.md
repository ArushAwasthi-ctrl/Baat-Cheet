# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Repository overview

Baat Cheet is a real-time chat application planned as a MERN stack system (MongoDB, Express, React, Node.js) with Redis, Socket.IO, and Cloudinary. In this repo, the implemented code focuses on the **Node.js/Express backend**, specifically the **authentication and email OTP flow**. The frontend folder currently has no committed code.

Key backend responsibilities (current state):
- User registration and verification via OTP (email)
- JWT-based authentication (access + refresh tokens)
- Session and rate limiting data stored in Redis
- Email delivery via BullMQ-backed background workers

For the broader product and API surface, see `PRD_BaatCheet_v1.0.md` at the repo root.

---

## Backend: common commands

All backend commands should be run from `backend`.

```bash path=null start=null
cd backend
```

Install dependencies:

```bash path=null start=null
npm install
```

Run the backend in development mode (with `nodemon`):

```bash path=null start=null
npm run dev
```

Run the backend in production mode (plain Node):

```bash path=null start=null
npm start
```

Format the backend codebase with Prettier:

```bash path=null start=null
npm run format
```

### Tests and linting

There are **no test or lint scripts** defined yet in `backend/package.json`. Before assuming commands like `npm test` or `npm run lint` exist, check and add them under the `scripts` section when a test runner or linter is introduced.

### Background email worker

Email sending is designed to run via a BullMQ worker in `backend/workers/email.worker.js`, using the same Redis instance as the main app. When you wire this up, you will typically run it as a separate Node process, for example:

```bash path=null start=null
cd backend
node workers/email.worker.js
```

(If you change the worker module name or entrypoint, update this accordingly.)

---

## Environment configuration

The backend is environment-driven. Before starting the server, ensure the following env vars are set (e.g. via a `.env` file loaded by `dotenv` from `backend/index.js`).

### Core infrastructure

- `MONGODB_URI` – **preferred** full MongoDB connection string. If not set, the server will build a URL using the variables below.
- `DB_USERNAME`, `DB_PASSWORD`, `DB_NAME` – used to construct a fallback MongoDB Atlas URI when `MONGODB_URI` is absent.
- `REDIS_URL` – Redis connection URL used by both the app and BullMQ queues.
- `PORT` – Express HTTP port (defaults to `9990` if not provided).

### Auth and tokens

Used across `backend/models/Users.js`, `backend/controllers/auth-controller.js`, and `backend/middlewares/auth-middleware.js`:

- `ACCESS_TOKEN_SECRET`, `ACCESS_TOKEN_EXPIRY` – for signing and expiring access tokens.
- `REFRESH_TOKEN_SECRET`, `REFRESH_TOKEN_EXPIRY` – for refresh tokens persisted in Redis.

### HTTP and CORS behaviour

Configured in `backend/app.js`:

- `NODE_ENV` – controls logging (`morgan`) format and `secure` cookie flags.
- `CORS_ORIGINS` – comma-separated list of allowed origins (defaults to `http://localhost:3000` if unset).

### Mail delivery (MailTrap + Mailgen)

Used in `backend/utils/mailgen.js` for OTP and other transactional emails:

- `MAIL_TRAP_HOST`
- `MAIL_TRAP_PORT` (numeric; if set to `465`, the transporter uses SSL)
- `MAIL_TRAP_USERNAME`
- `MAIL_TRAP_PASSWORD`

These are used to configure a Nodemailer transport that sends HTML and plaintext emails generated by Mailgen.

---

## High-level backend architecture

The backend is a monolithic Node.js application organized around:

- **Entry + infrastructure bootstrapping**
- **Express application setup** (HTTP, CORS, security)
- **Auth routes and controllers**
- **Persistence and caching** (MongoDB + Redis)
- **Background jobs** (BullMQ for email)
- **Shared utilities** (errors, responses, async handler, mail templating)

### Process & bootstrapping (`backend/index.js`)

- Loads environment variables via `dotenv`.
- Constructs the MongoDB URI (prefers `MONGODB_URI`, otherwise uses `DB_USERNAME`/`DB_PASSWORD`/`DB_NAME`).
- Connects to MongoDB via `db/dbCall.js` and to Redis via `redis/redisClient.js`.
- Creates an HTTP server from the Express app (`app.js`) and starts listening on `PORT`.
- Implements graceful shutdown hooks for `SIGINT`/`SIGTERM` to close Redis, Mongo connections, and the HTTP server.

This file is the **single entrypoint** for the backend service and is the right place to integrate additional infrastructure (e.g. Socket.IO, further queues) so they share the same HTTP server and lifecycle.

### Express app & middleware (`backend/app.js`)

`app.js` is focused on request/response concerns and is kept free of infrastructure wiring:

- Sets up JSON and URL-encoded parsers and `cookie-parser`.
- Configures CORS using `CORS_ORIGINS`, with credentials enabled and origin validation handled programmatically.
- Applies `helmet` (security headers), `compression` (gzip), and `morgan` (logging), with behaviour gated by `NODE_ENV`.
- Mounts the auth router under `/api/auth`.
- Defines a JSON `404` handler and a centralized error handler that understands the custom `ApiError` shape.

When adding new features, follow this pattern: mount new routers here (e.g. `/api/chats`, `/api/messages`), keeping `app.js` as the central HTTP composition layer.

### Routing & validation (`backend/routes` and `backend/validators`)

- `routes/auth-routes.js` wires HTTP endpoints to controller methods and validation middleware. Each route follows a clear pipeline: **validators → validation middleware → controller**.
- `validators/validate.js` exports:
  - `userRegisterValidator()` – validates `email`, `username`, `password` with constraints on format and strength.
  - `userLoginValidator()` – validates login payload.
- `middlewares/validator-middleware.js` inspects `express-validator` results, and if any errors exist, throws an `ApiError` with a structured `errors` array.

This split keeps payload validation logic close to routes but separate from business logic in controllers.

### Auth workflow & controllers (`backend/controllers/auth-controller.js`)

The auth controller file contains a complete authentication lifecycle.

Key flows:

1. **Registration (`registerUser`)**
   - Checks uniqueness of `username`/`email` in `Users` collection.
   - Applies rate limiting via Redis using keys like `register:ratelimit:<email>`.
   - Generates a 6-digit OTP and stores a JSON blob `{ username, email, password, otp }` in Redis under `register:<email>` with a 5-minute expiry.
   - Enqueues an email job on the `sendMail` queue using `emailQueue`, with content from `OTPVerificationMailGenContent`.

2. **OTP verification (`verifyOtp`)**
   - Reads the temporary data from Redis, validates the OTP, and ensures the user does not already exist.
   - Hashes the pending password with `bcrypt` and creates a verified `User` document (setting `isVerified`, `status: "online"`).
   - Generates access and refresh JWTs using model methods, hashes the refresh token, and stores it in Redis under `refresh:<userId>`.
   - Clears temporary registration and rate-limit keys from Redis.
   - Sets `accessToken` and `refreshToken` as HTTP-only cookies with environment-aware options and returns a structured `ApiResponse`.

3. **Login (`loginUser`)**
   - Fetches the user by email, ensures the account is verified, and uses the model’s `validatePassword` method to check credentials.
   - Issues new access and refresh tokens, hashes the refresh token, and stores it in Redis under `refresh:<userId>`.
   - Sets both cookies and returns user info via `ApiResponse`.

4. **Logout (`logoutUser`)**
   - Relies on `auth-middleware` to attach `req.user`.
   - Updates the user document to mark them offline and set `lastSeen`.
   - Deletes the Redis refresh token entry and clears both auth cookies.

5. **Token refresh (`refreshToken`)**
   - Reads the `refreshToken` cookie and verifies it using `REFRESH_TOKEN_SECRET`.
   - Looks up the hashed token in Redis (`refresh:<userId>`) and compares it to a freshly hashed version of the cookie value.
   - If they match, fetches the user (excluding password) and issues a new access token, updating the `accessToken` cookie.

These flows together implement a **cookie-based JWT auth system with Redis-backed refresh token tracking and OTP-based signup**, which is central to the backend’s security model.

### Auth middleware (`backend/middlewares/auth-middleware.js`)

- Extracts the `accessToken` cookie and verifies it using `ACCESS_TOKEN_SECRET`.
- Loads the corresponding user from MongoDB (excluding password) and attaches it to `req.user`.
- Differentiates between expired and invalid tokens via `ApiError` messages, allowing the frontend to distinguish between “refresh needed” vs “re-login required”.

This middleware is the gatekeeper for any protected route (currently `/logout`); any new protected route should reuse it.

### Data models (`backend/models/Users.js`)

The `User` model encapsulates both schema and auth helpers:

- Schema fields for identity and profile: `username`, `email`, `password`, `avatar`, `bio`, `status`, `lastSeen`, `friends`.
- Auth helper methods:
  - `createAccessToken()` – signs a JWT with minimal user data and `ACCESS_TOKEN_SECRET`/`ACCESS_TOKEN_EXPIRY`.
  - `createRefreshToken()` – signs a JWT containing only the user id with `REFRESH_TOKEN_SECRET`/`REFRESH_TOKEN_EXPIRY`.
  - `validatePassword(password)` – compares plaintext password with the stored hash using `bcrypt`.
  - `validateRefreshToken(refreshToken)` – verifies the refresh token (used conceptually alongside Redis checks).

This design keeps JWT and password logic inside the model, so controllers operate at a higher level.

### Persistence & caching (`backend/db` and `backend/redis`)

- `db/dbCall.js` wraps `mongoose.connect(dbUrl)` and logs the connected host. On error, it logs and terminates the process, so the app doesn’t run without a database.
- `redis/redisClient.js` creates and exports a singleton Redis client:
  - `redisCall(redisUrl)` initializes `createClient({ url })`, attaches error logging, connects, and logs success.
  - `redisClient` is also exported and used throughout the app (auth controller, queues, workers) as the shared Redis connection.

This arrangement centralizes connection management and ensures Redis is available before the HTTP server starts.

### Background jobs & email (`backend/queues` and `backend/workers`)

The email pipeline is split into **job enqueueing** and **job processing**:

- `queues/email.queue.js` defines a BullMQ `Queue` named `sendMail`:
  - Uses the shared `redisClient` as its connection.
  - Configures retry behaviour (2 attempts, exponential backoff) and automatic cleanup.
- `workers/email.worker.js` defines a BullMQ `Worker` on the same queue name:
  - Uses the same Redis connection.
  - For each job, extracts `{ email, subject, mailGenContent }` and calls `sendEmail()` from `utils/mailgen.js`.

The controller never sends email directly; it only enqueues jobs. This separation is important when scaling or when email delivery becomes slower than HTTP request lifecycles.

### Utility layer (`backend/utils`)

- `api-error.js` – a custom error class carrying `status`, `message`, `success`, and `errors`, designed to work with the global error handler in `app.js`.
- `api-response.js` – a unified success response wrapper that standardizes `status`, `data`, `message`, and a derived `success` flag.
- `asyncHandler.js` – wraps async route handlers and forwards rejections to Express’s error pipeline, which is used by controllers and middleware.
- `mailgen.js` – orchestrates Mailgen + Nodemailer for email sending and provides `OTPVerificationMailGenContent` for OTP emails.

Future utilities (e.g. for logging, metrics, or Socket.IO helpers) should follow this pattern and live alongside these modules.

---

## How to extend this backend safely

When implementing new features (e.g. chats, messages, group management) using this codebase:

- **Mount new HTTP routes in `app.js`** and keep cross-cutting middleware (CORS, security, logging) centralized.
- **Reuse the auth middleware** for any route that needs authenticated user context.
- **Follow the controller pattern** in `auth-controller.js`: keep business logic in controllers, glue it with models, and use `asyncHandler` with `ApiError`/`ApiResponse` for consistent error and success shapes.
- **Reuse Redis patterns** for short-lived state (presence, rate limits, token tracking) to stay consistent with how registration and tokens are handled.
- **Use queues for slow work** (e.g. notifications) rather than doing it inside HTTP request handlers, mirroring the email OTP workflow.
